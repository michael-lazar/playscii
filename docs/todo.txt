TODO

current tasks:

"rooms" concept:
- standardized object that contains/manages:
-- groups of objects (some non-exclusive with other rooms, eg player)
-- triggers (overlapping but not colliding objects) serve as portals to other rooms (edge of screen triggers, teleporters)
-- visibility/collision of objects
-- some objects are respawn-on-enter / destroy-on-exit
-- ambient sounds
-- current room name gets serialized in state data (where?), world does "enter room" on state load so you get per-room savegame support
-- if world.room is None / not in the room table, world behaves as normal
-- ensure out-of-room objects have near-zero overhead (collision)
-- how are rooms defined?  object lists must be generated after all objects have spawned
--- support dynamically generated room definitions a la ELC2 as well as predefined

# how to specify that an object is in all rooms?
if obj.in_all_rooms or (world.room and world.room in obj.rooms): obj.render()

load/save:
- serialize rooms in a separate list from objects
- room entry: list of objects, any other serializable properties
- in GameWorld.load_game_state, after all objects have been spawned, load rooms and pass each room's data into its init, same as objects
-- during init, each room finds its objects (string name to object reference)
-- GameRoom has get_dict same as GO
-- "current room" saved in serialized world properties

room UI:
- add/remove room from world
- add/remove objects from room: selected in view / choose from list of objects
- add/remove rooms from an object's list: choose from list of rooms
- "change current room"
- "show all rooms" toggle if you want to see the whole world at once

CameraPoint: non-GO markers (x, y, z) saved in state data, camera can be warped to them, locations can be added and removed via Camera in game menu

- fix object drag - probably inheriting bugs from Cursor.screen_to_world :[

use new file chooser for:
- convert image (any format supported by PIL)
- create palette from image (same)
- game dir (only show dirs in app/games/ and ~/documents/games/)

collision:
- AABB support (sometimes perfectly flat edges are needed)

- Art "instance" capabilities, so a script can change one object using the same as another without affecting both
-- write Art.copy to create an instance, save a reference to source, "restore" method
-- GameObject has its own "run script once / every N seconds" function which talks to its art instance, also function which calls art instance's "restore"
-- "save as" should create a new editable art in the session, not replace current one


---

new features / major improvements:

"movement context" for handling movement/physics:
- move accel, max velocity, stop velocity, gravity (if not global), friction, "specific-axis" bool

game distribution system:
- create new project: auto-create a class file with a stub GameObject subclass?
- ideal is something like LOVE does: single file you can associate with playscii and click to open
- possibly helpful: http://pysdl2.readthedocs.org/en/latest/modules/sdl2ext_resources.html

more complete example games:
- tetris - implementation of classic, all blocks drawn into a single Art, everything else implemented in a GameHUD (and maybe some background art)

collision:
- broadphase (tile system)
- AABB support (sometimes perfectly flat edges are needed)
- integrate AARR support

proper help screen:
- one screen of high level stuff, other screens are a generated listing of binds - use a given bind's function's __doc__ string

brushes:
- user-defined(?) ramps of characters
- painting with a brush puts down characters sampled from ramp:
-- sample randomly
-- sample based on # of tiles painted since click
-- sample based on pressure (possible with SDL2?)
- how is this data stored?  values are charset-specific

line definitions:
- user-defined(?) rules for which tile to use based on tiles painted since start of paint (click)
- probably shares some code with brushes

standard useful paint tools: draw line, flood fill

- if psci files get too huge, compress em with python's zipfile module (different extension needed?) as the json zips extraordinarily well
-- or just create a binary format that isn't broken like EDSCII's was? probably best to do once file format has stabilized
--- don't save "blank" tiles at all - determine a global/default FG/BG for majority of tiles

---

fixes / minor improvements:

game distribution: if autoplay_this_game is set, create a separate CFG file and don't create playscii documents/ + cache directories

generalized (works for any type of file, not just arts) file chooser:
- edit mode "set art" should invoke art file chooser
- draw a solid black char in scrollbar relative to where selection is in total item list.  clicking in scrollbar sets scroll index to there (can a button report where exactly it was clicked? just get mouse coords in screen tile space?)

detect GPUs/GL versions that won't run CRT shader well and auto-disable it in CFG?
- determine which setups would work better with this, and work out how to detect them reliably

volume support for playing sound FX
fade in/out support for music

undo/redo for adding or removing frames and layers :/

menu bar - when alt pressed, grey/darker bg on character that is an item's accelerator

main popup
- "use global settings" toggle for tools with an "affects X" mask - when true, setting one of the current tool's masks changes all tool's masks
- ability to "pin" popup so it stays on screen always
- arrow keys navigate between char and color pickers properly

- allow user to set view background color (per-art? in game world?)

shift-O: toggle between perspective and ortho views (steal unity's cool lerp)

state load / live reload: is there a way to determine when a class default has been changed and should / shouldn't override serialized data?

exporters for:
- C64 PRG file: single layer, C64 res (48x35 / 40x25) - see source of PETSCII editor http://www.kameli.net/marq/?page_id=2717 which does this
- ENDOOM (DOS charset, EGA palette)
- ASCII/ANSI art scene formats
