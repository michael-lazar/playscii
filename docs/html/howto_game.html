<!DOCTYPE html>
<head>
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>Playscii - Documentation (Game Mode)</title>
 <link rel="stylesheet" type="text/css" href="./darkgrey.css" title="dark grey"/>
 <link href='http://fonts.googleapis.com/css?family=Ubuntu' rel='stylesheet' type='text/css' />
 <style>
 .titlebar-playscii {
  height: 78px;
  padding: 0px 10% 0px 10%;
  align: left;
  background-repeat: repeat-x;
  background-image: url('logo_bg_tile.png');
 }
 .colorbar {
  height: 12px;
 }
 .item {
  padding: 0px 5%;
 }
 </style>
</head>
<body>

<div class="titlebar-playscii">
 <img src="pslogo_w_text2.png" alt="Playscii logo"/>
</div>
<div class="colorbar"></div>

<div class="main">

<br/>

<a id="intro"> <h4>Introduction</h4> </a>
<div class="block">
<p>
  While I've worked hard to make game creation in Playscii as easy and inviting as possible, it's still code-based, and much of this page will assume you know the basics of Python programming. Any kind of non-code-based game creation, such as visual programming, is a far-off someday thing. If you have ideas for how it could work, I'm <a href="http://vectorpoem.com/contact.html">interested in hearing them</a>.
</p>
<p>
  That said, you can make cool things happen in Game Mode with small amounts of easy to understand code, and you can "live tune" many things without having to restart Playscii to see your changes. This page will explain how.
</p>
<p>
  There are some topics best covered in this format, but for other things Playscii's code itself is the best documentation. Playscii can auto-generate nicely formatted HTML documentation of its code you can view in any web browser, without an internet connection. All you have to do is select "Generate documentation" from the Help menu. It may take a moment, but within a few seconds a table of contents page should open in your web browser. (If you're running from source instead of one of the pre-compiled builds, make sure you have the <tt>pdoc</tt> Python module installed.)
</p>
<p>
  If you've already generated the docs, the following link should take you to there:
  <h3> <a href="./generated/pdoc_toc.html">Playscii Auto-Generated Documentation</a> </h3>
</p>
</div>

<br/>

<h3>Table of Contents</h3>

<ul>
  <li> <a href="#intro">Introduction</a> </li>
  <li> <a href="#gamemode">Entering Game Mode</a> </li>
  <li> <a href="#menubar">Menu Bar</a> </li>
  <li> <a href="#loadgame">Loading Games</a> </li>
  <li> <a href="#newgame">Creating a New Project / Folder Structure of a Game</a> </li>
  <li> <a href="#gameworld">Game World Overview</a> </li>
  <li> <a href="#gameobject">Game Object Overview</a> </li>
  <li> <a href="#gamestate">Game States</a> </li>
  <li> <a href="#editing">the Editor Interface</a> </li>
  <li> <a href="#propertieseditor">the Properties Editor</a> </li>
  <li> <a href="#spawning">Spawning New Object Instances</a> </li>
  <li> <a href="#worldprops">World Properties and Globals</a> </li>
  <li> <a href="#camera">Camera</a> </li>
  <li> <a href="#rooms">Rooms</a> </li>
  <li> <a href="#hud">HUD</a> </li>
  <li> <a href="#debugview">Debug Views</a> </li>
  <li> <a href="#collision">Collision Detection and Resolution</a> </li>
  <li> <a href="#inputhandling">Handling Input</a> </li>
  <li> <a href="#console">the Developer Console</a> </li>
  <li> <a href="#workflow">Workflow</a> </li>
</ul>

<br/>

<a id="gamemode"> <h4>Entering Game Mode</h4> </a>
<div class="block">
  <p>
	By default Playscii launches into Art Mode. To switch between Art Mode and Game Mode, click the top right corner of the screen, or press <code>G</code>.
  </p>
</div>

<a id="menubar"> <h4>Menu Bar</h4> </a>
<div class="block">
<p>
  The menu bar along the top edge of the screen provides access to much of Playscii's functionality. Click a menu name to open it and select from the available commands. Many commands have an associated keyboard shortcut, displayed to the right of the menu entry.
</p>
<center><img src="./game_menubar.jpg" alt="the Game Mode menu bar"/></center>
</div>

<a id="loadgame"> <h4>Loading Games</h4> </a>
<div class="block">
<p>
  Games in Playscii are folders that contain code and assets (art, sounds) in specific subfolders. Playscii includes some games in its application folder, but your operating system's <tt>"Documents/Playscii/</tt> folder has a <tt>games/</tt> subfolder for you to put your own games in.
</p>
<p>
  You can launch a game in Playscii in one of three ways:
  <ul>
	<li> "Open game" from the Game menu will bring up a list of available games. Load one by clicking on it. </li>
	<li> Launch Playscii from the command line with <tt>-game mygame</tt> after it, where <tt>mygame</tt> is the game (ie the folder) you want to launch. </li>
	<li> Include a file called <tt>autoplay_this_game</tt> in the same folder as the Playscii executable, whose first line is the name of the game you want to load. This is a simple hack for distributing games to people who don't have Playscii - you can just zip up the folder and distribute that. </li>
  </ul>
</p>
</div>

<a id="newgame"> <h4>Creating a New Project / Folder Structure of a Game</h4> </a>
<div class="block">
<p>
  You can start a new project with "New game" from the Game menu, and Playscii will create the appropriate folders for you:
  <ul>
	<li> <tt>art/</tt> - PSCI art files used by your GameObjects go here. </li>
	<li> <tt>charsets/</tt> - If your game uses any <a href="./howto_art.html#customcharsets">custom character sets</a>, put them here. </li>
	<li> <tt>palettes/</tt> - If your game uses any <a href="./howto_art.html#custompalettes">custom color palettes</a>, put them here. </li>
	<li> <tt>scripts/</tt> - All Python scripts (<tt>.py</tt> extension) for your game go here. Playscii will create a generic "starter script" here, which may be helpful if you're new to writing Python scripts for game objects. </li>
	<li> <tt>sounds/</tt> - Sound effects and music for your game, in any format supported by <a href="http://www.libsdl.org/projects/SDL_mixer/">SDL2_mixer</a>, go here. </li>
	<li> <tt>start.gs</tt> - This is the default <a href="#gamestatefiles">game state save file</a> that will be loaded when you open your game. </li>
  </ul>
</p>
<p>
  When you create a new project, Playscii automatically creates a generic "starter script" in the <tt>scripts/</tt> folder, with a few things to help newcomers - if you already know what you're doing, you can delete or ignore it. This starter script defines two new "classes", or flavors, of game objects: a generic <a href="#gameobject">GameObject</a> subclass and a subclass of Player, which is simply a GameObject that moves around when you press the arrow keys. Before getting too deeply into these, though, a higher level overview of how all the classes fit together is in order.
</p>
</div>

<a id="gameworld"> <h4>Game World Overview</h4> </a>
<div class="block">
<p>
  In Game Mode, Playscii delegates game functionality to something called a GameWorld: loading game states, content, and scripts; managing the spawning and lifetimes of GameObjects; running much of the input->update->render loop that makes the simulation go; and handling Edit UI tasks such as selecting and dragging objects.
</p>
<p>
  GameObjects are, in turn, most of what a GameWorld thinks about. A GameObject can represent the player, a non-player character, an entire screen of level geometry, a powerup, a trigger that does something when entered, an invisible marker where another object appears, and so on.
</p>
<p>
  GameWorlds can also organize their objects into <a href="#gameroom">GameRooms</a>, so that only certain objects are visible and simulated at once, and can use a <a href="#gamehud">GameHUD</a> to render UI-appropriate information above everything else.
</p>
<p>
  The GameWorld class also has some functions that are most appropriate to its scope, such as managing <a href="./generated/game_world.html#game_world.GameWorld.play_music">music playback</a>, <a href="./generated/game_world.html#game_world.GameWorld.get_all_objects_of_type">getting collections of objects by type</a>, and <a href="./generated/game_world.html#game_world.GameWorld.get_colliders_at_point">global collision tests</a>. Have a look at the <a href="./generated/game_world.html">GameWorld generated documentation</a> for an idea of what it handles relative to the other moving parts.
</p>
</div>

<a id="gameobject"> <h4>Game Object Overview</h4> </a>
<div class="block">
<p>
The <a href="./generated/game_object.html">GameObject class</a> defined in the built-in <tt>game_object.py</tt> module provides the base capabilities of all objects, and you can extend this functionality by creating variants of that base class in the scripts you place in the game's <tt>scripts/</tt> subfolder. The <tt>game_util_objects.py</tt> module includes a few generic subclasses ready-made for things like the player, projectiles, NPCs, triggers, and spawners.
</p>
<p>
Every GameObject has two components that help it render (draw to the screen) and collide, respectively: a <a href="#rendering">Renderable</a> and a <a href="#collision">Collideable</a>. Renderables in turn can draw data from one or more <a href="">Art</a>s, pieces of art you can create in <a href="./howto_art.html">Art Mode</a> or generate on-the-fly with code.
</p>
<p>
GameObjects have many properties you can change, functions you can call and/or override, and concepts such as "state" and "facing" to let you define custom behaviors. Rather than try to detail all of them here, please have a look at the <a href="./generated/game_object.html">GameObject generated documentation</a> and <a href="./generated/game_util_objects.html">Game Object Utility Library generated documentation</a>, as well as the code for the <a href="#examplegames">example games</a>, for an idea of how these can be used.
</p>
</div>

<a id="gamestate"> <h4>Game States</h4> </a>
<div class="block">
<p>
Playscii can save the state of all objects in a GameWorld into a "save state file" not unlike a conventional savegame or <a href="https://en.wikipedia.org/wiki/Saved_game#Save_states">save state</a> in a game console emulator. The <tt>start.gs</tt> created with a new project defines the game's starting state, which you can modify how you like by adding and manipulating the objects therein. You can create additional save state files for testing purposes, or even to load in new segments of gameplay if there is no state carried over from previous segments.
</p>
<p>
Save a game's current state into a new state file with "Save new state..." from the State menu. "Save state" or <code>Control-S</code> saves over the last saved state - take care not to accidentally overwrite your <tt>start.gs</tt> with this - and "Load state" opens a list of save state files to choose from. <code>F2</code> quickly reloads the last loaded state file, which is handy for <a href="#workflow">rapid iteration</a>.
</p>
<p>
Much as <a href="./howto_art.html">Art</a> (<tt>.PSCI</tt> files) are just tiles, layers, and frames serialized into <a href="https://en.wikipedia.org/wiki/JSON">JSON</a>, save state files are all the GameObjects and GameRooms serialized into JSON, so it's possible to view and even manually edit them, though there's no non-bug reason you'd need to do this.
</p>
<p>
  It's worth noting that all GameObjects with the <tt>should_save</tt> property set <tt>False</tt> do not get saved into state save files. This is appropriate for certain kinds of objects, such as projectiles or spawned enemies whose lifetimes are managed in some other way, and/or for whom saving and loading would introduce unwanted complexity into how they work.
</p>
</div>

<a id="editing"> <h4>the Editor Interface</h4> </a>
<div class="block">
<p>
In Game Mode, the boundary between editing a game and playing it is intentionally fairly thin. The editor interface lets you create, manage, and modify GameObjects, and when this interface is disabled you're left with just the game itself, ie what players experience.
</p>
<p>
You can hide this UI at any time with "Hide edit UI" in the Game menu or <code>Shift-E</code>. When distributing games, you can add the line <tt>Application.can_edit = False</tt> to <a href="./howto_main.html#config"><tt>playscii.cfg</tt></a> which will prevent players from using the interface, switching into Art Mode, or doing anything besides just what you as a the game's designer intend.
</p>
<p>
The most basic actions one can do in this edit UI are <code>primary mouse button</code> on an object to select it and drag to move it. Selected objects have a thin pulsing outline that shows their "bounds", ie the edges of their current Art. Similar to Art Mode's <a href="./howto_art.html#tools">Select tool</a>, you can select multiple objcets at once: <code>Shift + primary mouse button</code> adds an object to the current selection set, while <code> Control + primary mouse button</code> removes an object from the selection set.
</p>
<p>
You can also select from a list of all objects in the world with "Select objects" in the Object menu, or <code>Control-L</code>. The aforementioned modifier keys have the same effect here as when you click in the world.
</p>
<p>
Selected objects will drag-move together as expected. You can also delete all selected objects with "Delete selected objects" in the Object menu.
</p>
</div>


<a id="propertieseditor"> <h4>the Properties Editor</h4> </a>
<div class="block">
<p>
The pane that appears on the right side of the screen when you have object(s) selected is the Properties Editor. It shows the properties on the selected object(s) that you're allowed to edit on a per-instance basis. Clicking on a property will bring up a window where you can enter its new value. If multiple selected objects have different values, this will be displayed in the property field instead of any single value.
</p>
<center> <img src="./game_propseditor.jpg" alt="properties editor" width="50%"/> </center>
<p>
The properties you edit in this UI are the very same properties that are declared in the object's class definition. If you want to change a value for all instances of this class, edit the code; if you want to change the value for a single instance, use the Properties Editor.
</p>
<p>
Each class defines which of its properties can be edited, and which will be saved to <a href="#gamestate">state files</a>. The <tt>serialized</tt> property is a list of string names of properties that will be saved <i>and</i> can be edited, while the <tt>editable</tt> property is a list of string names of properties that should be editable but <i>not</i> serialized - mainly useful for live tuning.
</p>
</div>

<a id="spawning"> <h4>Spawning New Object Instances</h4> </a>
<div class="block">
<p>
You can create new instances of the classes you've defined in scripts with "Spawn object" in the Object menu, or <code>Control-P</code>. This will bring up a list of available classes. Click one to select it, and then click in the main view to spawn an object at that location.
</p>
<p>
  You can also create new objects from existing ones with "Duplicate selected objects" in the Object menu.
</p>
</div>


<a id="worldprops"> <h4>World Properties and Globals</h4> </a>
<div class="block">
<p>
GameWorld is a core Playscii class, and it is a <a href="https://en.wikipedia.org/wiki/Singleton_pattern">singleton</a> not a GameObject: it doesn't serialize itself, nor is it an appropriate place for game-specific logic. In addition to classes like Player and Projectile, the <tt>game_util_objects.py</tt> module has two special classes that enable you to manage the world's state as objects: <a href="./generated/game_util_objects.html#game_util_objects.WorldPropertiesObject">WorldPropertiesObject</a> and <a href="./generated/game_util_objects.html#game_util_objects.WorldGlobalsObject">WorldGlobalsObject</a>.
</p>
<p>
Every GameWorld has a WorldPropertiesObject, but it's given a few status flags that ensure you can't select it, delete it, or spawn a second instance. Its purpose is to mirror the properties of the world itself, and then propagate those back to the world when loading a state, so that you can edit the world's properties much as you would any other object, with "Edit world properties" in the World menu. Here you can change things like the gravity applied to physical objects, whether or not the camera auto-locks on to the player, and various debug settings.
</p>
<p>
Every GameWorld also has a WorldGlobalsObject, which is typically a custom class defined for each game, where you can put logic that manages global state. When a save state file loads, it's spawned immediately after any saved objects, so whatever it's looking for is guaranteed to be there. Other game objects can always refer to it via <tt>self.world.globals</tt>.
</p>
<p>
By default this object isn't serialized, to keep a clear separation between world data and world logic, but this isn't carved in stone. The first released Playscii game, <a href="https://jp.itch.io/endless-ladder-climbing-2">Endless Ladder Climbing 2</a>, makes fairly heavy use of a WorldGlobalsObject to manage world state.
</p>
<p>
As WorldGlobalsObject is bound to be a custom class, you can let the world know which class to use by entering the class name in <tt>WorldPropertiesObject.globals_object_class_name</tt>.
</p>
</div>

<a id="camera"> <h4>Camera</h4> </a>
<div class="block">
<p>
A game's camera is not represented by a GameObject, rather its few properties are manipulated via the <a href="#worldprops">WorldPropertiesObject</a> (so its position at any given point is serialized in a save state file) or script code.
</p>
<p>
In addition to static positioning, a camera can have a "focus object" whose movement it tracks, set via <tt>Camera.focus_object</tt>. As a convenience, when <tt>GameWorld.player_camera_lock</tt> is True, the camera will try to stay locked on to the player.
</p>
<p>
As in Art Mode, you can manually set the camera's zoom level with "Set camera zoom" in the View menu, and you can set its position directly with the <a href="#console">dev console</a>.
</p>
<p>
It's sometimes useful to use a LocationMarker object to remember a camera position. "Move selected object(s) to camera" and "Move camera to selected object" in the View menu make it easier to do this: you can position the camera how you want it and then snap an object to it, and then later snap the camera to that object to restore the position.
</p>
<p>
<a href="#rooms">Rooms</a> can also set the camera position. This is explained in detail in the next section.
</p>
</div>


<a id="rooms"> <h4>Rooms</h4> </a>
<div class="block">
<p>
Sometimes your game will have multiple "screens" worth of content, like a large world to explore. It's usually easier, for both the designer and the computer, to not be thinking about every single object in such a world at all times. To this end, Playscii allows you to organize objects into Rooms, represented by the <a href="./generated/game_room.html">GameRoom</a> class.
</p>
<p>
Rooms are strictly an opt-in concept: every object keeps track of which rooms it's in, and an object that is not in any rooms is considered to be everywhere. So by default the world updates and renders every object in it, and you don't need to think about rooms at all if you're not using them. Most of the example games don't use rooms at all, while the <a href="#example_maze">Maze game</a> uses them extensively. If you've got Playscii open as you read these docs, opening the Maze game and poking at it might help you understand some of the functionality.
</p>
<p>
The game world has a notion of what the "current room" is, and by default it's None. Once you've created a room, with "Add room" in the Room menu, you can set it as current either with "Change current room" from the Room menu, or clicking on a room's name in the list at the bottom of that same menu - a checkmark will appear next to the current room.
</p>
<p>
Once you have a room set as current, you can set which objects are in it with "Add selected objects to this room" and "Remove selected objects from this room". "Add/remove objects from this room" will bring up a list in the left pane, in which objects in the room are highlighted and clicking adds or removes them. On the code side, if you have a handle to the room itself you can do this with <tt>GameRoom.add_object_by_name</tt> (passing the object's string name), <tt>GameRoom.add_object</tt> (passing the object by reference), <tt>GameRoom.remove_object_by_name</tt>, and so on.
</p>
<p>
Again, objects that you know will always be on-screen - it's usually a safe bet that the player is, for example - can be kept outside of all rooms.
</p>
<p>
Objects that are not in the current room (and aren't "everywhere" as described above) are not rendered or updated (unless their <tt>GameObject.update_if_outside_room</tt> property is set True), so as you're organizing objects you'll see some of them blink out of sight.
</p>
<p>
If you get confused and what's where, you can toggle a global view of all objects in all rooms with "Show all rooms" in the Room menu.
</p>
<p>
Managing room transitions and camera changes as the player moves around are very common uses of rooms - again, the Maze game's explorable world does this a lot. If a room's <tt>camera_marker_name</tt> is set, the camera will warp there when the room is entered. You can easily set this with "Set this room's camera marker" in the Room menu.
</p>
<p>
Often you'll want to warp the player to a different room when they reach the "edge" of it. You need to provide two bits of information to the room to make this work: give it an object to define the "edges" of the room, with "Set this room's edge object" in the Room menu, and telling the world which room or point to warp to when the player reaches the north/south/east/west edges of those bounds, with "Set this room's edge warps". In the pane on the left, you'll notice you can select both room names and object names. If a room name is given for an edge warp, the player will warp to that room; if an object name is given, the player will warp to that object's location and change to that object's room.
</p>
<p>
Technically this "edge warp" functionality is doing something very similar to the <a href="./generated/game_util_objects.html#game_util_objects.WarpTrigger">WarpTrigger</a> class, but its close integration with the room concept makes it somewhat easier.
</p>
<p>
A few more intricacies of Rooms are covered in the <a href="#example_maze">Maze game</a> section below, so have a look if any of this isn't clear.
</p>
</div>

<a id="hud"> <h4>HUD</h4> </a>
<div class="block">
<p>
The GameHUD (HUD is short for Heads-Up Display) is a simple singleton member of GameWorld that draws in 2D screen space and manages its Renderables directly, useful for UI/HUD like purposes. The whole point of a GameHUD is that it has game-specific logic, so you'll want to create a subclass in your scripts and set your <tt>GameWorld.hud_class_name</tt> to its name via the <a href="#worldprops">WorldPropertiesObject</a>, much as you set <tt>globals_object_class_name</tt>.
</p>
<p>
  When you're setting Renderable sizes and locations in a GameHUD, remember that it uses OpenGL screen space coordinates, where (0,0) is the center of the screen and (1,1) is the top right corner.
</p>
</div>

<a id="debugview"> <h4>Debug Views</h4> </a>
<div class="block">
<p>
Game Mode has a few visualization modes that are helpful for debugging in the View menu:
<ul>
<li> Show all object origins: show each object's "origin" or XYZ location using a familiar red/green/blue axis marker. </li>
<li> Show all object bounds: show each object's "bounds", ie the edges of their current Art. </li>
<li> Show all object collision: show each object's collision shapes - see the <a href="#collision">Collision</a> section below. </li>
</ul>
</p>
<p>
If you want to use debug lines for a more specific purpose, check out the <tt>renderable_line.DebugLineRenderable</tt> class - you can feed it a list of 3D coordinate tuples and it will draw those lines in the world.
</p>
</div>

Collision Detection and Resolution
three types: circle, box (AABB), and tile.
tune an object's collision size with col_radius/width/height, see it with [debug views]
tiles: turn an art's "collision layer" into boxes
static or dynamic - tile must be static, circles and boxes can be static or dynamic
fast_move_steps - use it if an object is tunneling


Handling Input
objects can handle input if you set [flag]. override handle_key_up/down to do stuff when that key is pressed.

the Developer Console
dev console has some specific commands, type "help" to see a list of them
dev console also takes any python expression, and has access to the global application namespace. so you can do stuff like [examples]: get and set object properties directly, built-in aliases: app, world, camera, sel, player
be careful though, it's definitely possible to crash the application with that kind of power!

Workflow
(quick reload, states)
game mode designed so you can "live edit" and see your changes instantly as much as possible without having to restart playscii every time you make a small change.
most property changes should be reflected instantly, and game scripts reload with the game state file, so a quick F2 press is usually all that's needed.
if you need the game in a specific state to test something, that's exactly what save states are for; create as many states as you need.
changes from art mode also take effect instantly, so you can tune a piece of art or animation, press G and see it in-game.

Tour of Example Games
cronotest: art test, character with states and facings, basic collision
maze: rooms, large tile-based collision, warptriggers, spawners, camera markers
flood: operations on an object's Art, simple object input handling
shmup: projectiles, more spawners, generated starfield
platso: platformer, physics, AI uses a simple timer for wall checks
  
<br/><br/>

<b><a href="./howto_main.html"><< back to main documentation page</a></b>
							 
<br/><br/><br/>

</div>
</body>
